# 리터럴과 변수 상수, 데이터 타입

- 자바스크립트의 값은 원시값(primitive) 또는 객체(object)
  - 원시 타입은 항상 불변 원시값 5,6 은 서로 다르다.
  - 원시타입은 6 가지 - 숫자, 문자열, 불리언, null, undefined, 심볼 -
  - 불변성이라는 말이 변수가 바뀔수 없다는 말이 아님.
- 객체의 유연한 성질 때문에 커스텀 데이터 타입을 마들때 객체를 많이 사용. 자바스크립트에는 다음과 같이 몇가지 내장된 객체 타입이 있음 - Array, Date, RegExp, Map 과 WeakMap, Set 과 WeakSet
- 원시타입중 숫자와 문자열, 불리언에는 각각 대응하는 객체 타입인 Number, String, Boolean 이 있습니다.

### 숫자

- 자바 스크립트도 다른 프로그래밍 언어와 마찬가지로 부동소수점 숫자 형식을 사용합니다. -더블- 그런데 더블 형식의 근사치 결과는 종종 사람들을 당혹스럽게 만들곤 합니다. 예를들어 0.1 + 0.2 는 0.30000000000000~004 를 반환합니다. 자바스크립트에 버그가 있거나 덧셈을 할줄 몰라서가 아닙니다. 이건 무한한 값을 유한한 메모리안에서 가능한 정확히 짐작하려다 생긴 결과.
- 자바스크립트에는 숫자형 데이터 타입이 하나 밖에 없다. 따라서 고성능 정수 연산이나 정밀한 소수점 연산이 필요한 애플리케이션에서 쓸 수 없게 만든 선택

### 문자열

- 문자열 이스케이프 `\`
- 자기 자신을 이스케이프 `\\`
- 문자열 + 숫자
  - 자바스크립트는 필요하다면 숫자가 들어있는 문자열을 자동으로 숫자로 바꿉니다. 이런 일이 언제 일어나는지 어떻게 일어나는지 못하면 혼란스러울 수 있다.
  ```js
  const result1 = 3 + '30'; // '330'
  const result2 = 3 * '30'; // '90'
  ```
  - 모호함을 피하기 위해서 숫자를 문자열 안에 넣지 마십시오.

### Symbol

심볼은 유일한 토크을 나타내기 위해서 ES6 에서 도입한 새 데이터 타입입니다. 심볼은 항상 유일합니다. 다른 어떤 심볼과도 일치하지 않습니다. 이런 면에서 심볼은 객체와 유사합니다. 객체는 모두 유일합니다. 항상 유일하다는 점을 제외하면 시몹ㄹ은 원시 값의 특징을 모두 가지고 있으므로 확장성 있는 코드를 만들 수 있습니다.

심볼은 `Symbol()`생성자로 만듭니다. 원한다면 생성자에 간단한 설명을 추가할 수 있습니다. - 자바스크립트의 객체지향 프로그램에 익숙하다면 심볼을 만들때 new 키워드를 사용할 수 없으며, 대문자로 시작하는 식별자는 new 와 함께 쓴다는 불문율의 예외임을 새로 기억해야 합니다. -

```js
const RED = Symbol('The color of a sunset');
const ORANGE = Symbol('The color of a sunset');
RED === ORANGE; // false
```

### null 과 undefined

null 과 undefined 모두 존재하지 않는 것을 나타냅니다. 일반적인 규칙을 제시한다면, `null`은 프로그래머에게 허용된 데이터 타입이며 `undefined` 자바스크립트 자체에서 사용한다고 기억하십시오. 이 규칙이 강제는 아닙니다. 프로그래머도 언제든 `undefined`를 사용할 수 있지만, 꼭 필요한 때만 사용하도록 주의해야 합니다. 필자가 변수에 직접 undefined 를 할당하는 경우는, 아직 값이 주어지지 않은 변수의 동작을 고의로 흉내내야 할 때 뿐입니다. 변수의 값을 아직 모르거나 적용할 수 없는 경우에는 대부분 `null`이 더 나은 선택입니다. 초보 프로그래머들은 불확실할때는 `null`을 사용하라고 배우니까요, 변수를 선언하기만 하고 명시적으로 값을 할당하지 않으면 그 변수에는 기본적으로 `undefined`가 할당 됩니다.

### 객체

객체의 본질은 컨테이너 입니다. 컨테이너의 내용물은 시간이 지나면서 바뀔수 있지만 내용물 -프로퍼티- 이 바뀐다고 컨테이너가 바뀌는 건 아닙니다. 프로퍼티 값도 객체가 될 수 있습니다.

객체지향 프로그래밍(OOP)에 익숙하다면 자바스크립트 객체를 OOP 에 어떻게 사용하는지 궁금할 겁니다. 지금은 객체를 범용 컨테이너라고 생각하십시오. OOP 에 대해서는 9 장에서 설명합니다.

### Number, String, Boolean 객체

이 장 초반에서 숫자와 문자열, 불리언에는 각각 대응하는 객체타입 Number, String, Boolean 이 있다고 언급했습니다. 이들 객체에는 두가지 목적이 있습니다. 하나는 `Number.INFINITY` 같은 특별한 값을 저장하는 것이고, 다른 하나는 함수 형태로 기능을 제공하는 것입니다.

```js
CONST s = "hello";
s.toUpperCase();  // "HELLO"
```

위 예제의 s 는 마치 객체처럼, 즉 함수 프로퍼트를 가진 것처럼 보입니다. 하지만 우리는 s 가 분명 문자열 타입임을 알고 있습니다. 자바스크립트는 일시적인 String 객체를 만든겁니다. 이 임시 객체에 toUpperCase 함수가 들어있습니다. **자바스크립트는 함수를 호출하는 즉시 임시 객체를 파괴합니다.** 객체가 임시로 만들어진다는 사실은 다음과 같이 문자열에 프로퍼티를 할당해 보면 알 수 있습니다.

```js
const s = 'hello';
s.ration = 3; // 임시객체 생성
s.rating; // 생성되자마자 파괴되어 undefined 출력
```

### 숫자로 바꾸기

1. Num 사용
   ```js
   const numbStr = '33.3';
   const num = Number(numbStr);
   ```
1. `parseInt`나 `parseFloat`함수를 사용
   - 장점 : 기수(10 진수, 16 진수)를 param 으로 넘길 수 있음
   - `const b = parseInt("3a", 16)` 16 진수 3a 를 10 진수로 바꿉니다.
1. Date 객체를 숫자로 바꿀때는 valueOf() 메서드를 사용합니다.
   ```js
   const d = new Date();
   d.valueOf();
   ```

### 문자열로 반환

Date 객체의 toString()객체는 쓸만한 결과를 반환. 객체의 toString 을 [object Object]를 반환하기 때문에 9 장에서 이 것을 수정해서 유용한 문자열 표현을 반환하게 할 수 있다.

> 자바스크립트의 숫자는 모두 더블형식

# 표현식과 연산자

### 비교 연산자

- 되도록 일치 연산자만 사용하고, 원하는 결과가 나오지 않을때만 동등 연산자 사용
  - 일치 strict equality
    - 같은 타입이고 값도 같다면(원시타입) 이 값을 일치한다고 한다.
    - `===`
  - 동등 loose equality
    - 문자열 '33'은 숫자 33 으로 변환할수 있으므로 이 둘은 동등하지만 타입이 다르므로 일치하지는 않는다.
    - `==`

### 숫자 비교

- `NaN`은 자신을 포함하여 무엇과도 같지 않습니다. NaN === NaN, NaN == NaN 모두 false 이다. `isNaN()` 사용. 자바스크립트의 숫자는 모두 더블 형식이고 더블형식은 근사치이기 때문에, 숫자를 비교하다보면 원하지 않는 결과가 나온다.

아래 결과는 영원히 실행된다.

```js
while (true) {
  n += 0.1;
  if (n === 0.3) break;
}
```

따라서 Number.EPSILON 과 관계 연산자를 사용해서 '느슨하게' 비교해야 한다.

```js
while (true) {
  n += 0.1;
  if (Math.abs(n - 0.3) < Number.EPSILON) break;
}
```

```
3 + 5 + "8" // 문자열 "88"
"3" + 5 + 8 // 문자열 "358"
```

### 거짓

자바스크립트에서 거짓 값은 다음과 같습니다.

- undefined
- null
- false
- 0
- NaN
- '' (빈문자열)

이들 외에 모든 값은 참

참 값은 값

- 모든 객체 valueOf() 메서드를 호출했을때 false 를 반환하는 객체도 참 같은 값에 속합니다.
- 배열 빈 배열도 참 같은 값에 속합니다.
- 공백만 있는 문자열
- 문자열 "false"

### 단축평가

```js
const skipIt = true;
let x = 0;
const result = skipIt || x++;
```

위 예제의 결과는 result 는 true 이고, 단축 평가가 일어나므로 증가 연산자에 해당하는 표현식은 실행되지 않고 x 의 값은 그대로 0 이 된다. `skipIt`을 false 로 바꾸면 x 값은 증가한다.

```js
const doIt = true;
let x = 0;
const result = doIt && x++;
```

위 AND 연산자에서는 result 의 결과는 `false`가 아닌 0 이다. **피연산자가 불리언이 아니라면, 결과를 겨정한 값이 반환된다.** 위와 같은 특징때문에 아래와 같은 패턴이 자주 쓰인다.

```js
const options = suppliedOptions || { name: 'default' };
```

### typeof 연산자

typeof 연산자는 피연산자의 타입을 나타내는 문자열을 반환한다. 이 연산자는 자바스크립트의 일곱가지 데이터 타입(undefined, null, 불리언, 숫자, 문자열, 심볼, 객체)을 정확히 나타내지 못하며 끝없는 혼란을 초래했고 계속 비판을 받았습니다.

typeof 연산자는 typeof null 을 "object"라고 판단하는데, 이런 행동은 버그라고 해도 할 말이 없습니다. null 은 당연히 객체가 아니라 원시 값입니다. typeof null 이 "object"라고 판단하는데 이런 행동은 버그라고 해도 할말이 없습니다. null 은 당연히 객체가 아니라 원시 값입니다. typeof null 이 "object"를 반환한다는 사실을 이용하는 코드가 너무 많이 생겨서 이제는 돌이킬 수 없게 됐고, 명세에 수록됐으므로 바꿀수도 없습니다.

typeof 는 배열과 배열 아닌 객체도 정확히 구분하지 못합니다. 함수(객체의 특별한 타입)는 정확히 식별하지만, typeof []는 "object"를 반환합니다.

### 해체 할당

```js
const obj = { b: 2, c: 3, d: 4 };

// 해체할당
const { a, b, c } = obj;
console.log(a); // undefined
console.log(b); // 2
console.log(c); // 3
console.log(d); // ReferenceError
```

객체 해체는 할당만으로도 이뤄질 수도 있지만 그럴려면 반드시 괄호를 써야 합니다. 괄호를 쓰지 않으면 자바스크립트는 표현식 좌변을 블록으로 해석합니다.

```js
const obj = {b:2, c:3, d:4};
let a, b, c;

// 에러
{a, b, c} = obj;

// 동작
({a, b, c} = obj);
```

배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응합니다.

```js
const arr = [1, 2, 3];

//배열 해체 할당
let [x, y] = arr;
x; // 1
y; // 2
z; // ReferenceError
```

확산 연산자 (...)를 이용하면 남은 배열 요소를 모두 할당합니다.

```js
const arr = [1, 2, 3, 4, 5];

let [x, y, ...rest] = arr;

x; // 1
y; // 2
rest; // [3,4,5]
```

### 객체와 배열 연산자

- `instanceof` 프로토타입 체인 테스트 연산자
- `delete` 삭제연산자

### 표현식과 흐름 제어 패턴

if...else 문의 목적이 변수의 값을 얻는 것이라면 3 항 연산자를 쓰는 편이 좋습니다.

...

if 문을 단축평가하는 OR 표현식으로 바꾸기. 할당이 주 목적인 if 문은 단축평가를 사용하는 OR 표현식을 써서 간결하게 줄일 수 있습니다. 3 항 연산자는 if...else 문보다 거의 항상 더 좋지만, 단축 평가는 뚜렷하게 무엇이 좋다고 말하기는 어렵습니다.

```js
if (!options) options = {};
```

앞으 코드는 다음과 같이 쓸수 있습니다.

```js
options = options || {};
```
