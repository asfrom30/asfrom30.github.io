# Clean code


## Before first chapter

### 2010년 번역판 옮긴이 서문
* 프로그램을 짜다 보면, 코드를 쓰는 시간보다 코드를 읽는 시간이 훨씬 많다는 사실을 알고 있다면, 이 책에서 제시하는 보이스카우트 규칙을 다른 모든 규칙에 앞서 특히 신경써서 봐야한다. 우리 개발자들에게는 체크아웃해 코드를 꺼낼때보다 체크인해서 코드를 넣을 때 더 깨끗한 상태로 만들어야 할 의무가 있다.

* 프로그램을 잘짜는 사람과 같이 일하면 가장 좋다. 그게 어려우면 남이 잘 짜놓은 프로그램을 보는 것이 효과적이다. 대신 생각의 흐름을 파악하기 어려우므로 그만큼 노력이 필요하다.
  > 다른 프로그램의 코드를 따라 치는 것으로 파악을 했는데 이 방식은 시간이 너무 오래 걸린다. 디버그 할때처럼 유심히 보고, 머리속으로 코드를 그리면서 파악하려고 해보자

### 추천사
* 지금도 아키텍쳐는 소프트웨어에서 첫 제품을 인도하는 부분을 설명하는 하나의 메타포일 뿐이다. 건축가가 막 지어진 건물을 인도하는 상황을 머리에 떠올리면 되겠다. 스크럼과 애자일에 관심이 모아진 현재는 제품을 신속하게 시장에 출시하는 방법론을 강조한다. 우리는 (소프트웨어) 공장을 전손력으로 가동해 소프트웨어를 재빨리 내놓고 싶어한다. 즉 개발자들은 제품 백로그나 사용자 스토리를 토대로 제품을 생산한다고 생각하고, 느낀다. 스크럼은 이런 일본 자동차 제조업, 즉 생산 라인 세계에서 많은 영향을 받았다.
<br>&nbsp; 하지만 심지어 자동차 업계도 대다수 활동은 제조가 아니라 유지보수다. **소프트웨어는 80% 이상이 소위 "유지보수"다.** 좋은 소프트웨어를 만드는 데 치중하는 전형적인 서양식 사고를 포용하는 대신, 우리는 좀 더 건축 업계의 수리공이나 자동차 업계의 수리공처럼 소프트웨어 개발자를 생각해야 한다.
<br>&nbsp; TPM이라는 품질 관리론이 일본 업계에 등장했다. TPM은 생산이 아니라 유지 보수에 초점을 맞췄다. 5S원칙은 선택이 아니라 필수다. **훌륭한 소프트웨어 기법은 집중, 침착, 사고라라는 규율을 요구한다. 행동이 전부가 아니다. 무작정 설비를 돌려 제품만 찍어낸다고 다가 아니다.**

* 진정으로 책임 있는 개발자라면 제품 생명주기까지 고려해야 한다는 의미다. TPM 아래에서 자동차나 다른 기계장비를 유지보수하게 되면 **유지보수를 유기** 하는 일은 거의 일어나지 않는다. TPM 아래에서는 한걸음 더 나아간다. 매일 기계를 검사하고, 닳아버린 부품을 교체하고, 주기마다 엔진오일을 교체헤 고장을 미연에 방지한다. **코드에서는 인정사정없이 리팩터링** 하라는 이야기이다. 한걸음 더 나갈 수도 있다. 지난 50여년 동안 TPM 운동은 혁신을 일으켜 아예 처음부터 유지보수하기 쉬운 기계를 만들어냈다. 읽기 좋은 코드는 돌아가는 코드만큼이나 중요하다.

* 패턴과 패턴언어의 아버지인 건축가 크리스토퍼 알렉산더는 **모든 설계 행위를 작은 규모로 이루어지는 국부적인 수리 행위로 보았다.** 그리고 전체 구조를 훌륭히 만드는 것만이 자인으로서 건축가가 유일하게 해야할 일의 범위라고 했다. (그래서 보다 크게 주택의 형태를 만들어가는 것은 패턴과 거주자의 응용에 맡겨도 된다고 생각했다.) 주택 디자인은 집에 새 방을 추가하는 이외에도 페인트를 새로 칠하고, 낡은 카펫을 교체하고 부엌 싱크대를 바꾸는 등 계속해서 이어진다. 프랑스 시인인 폴 발레리는 시란 영원히 미완성이라 끝없는 재작업이 필요하며 포기할때에만 끝난다고 말했다.

> 프로그램을 만들때 처음 구조만 잘 이어주고, 하나씩 돌아가면서 고쳐(유지,보수) 해주는 것. 이런 방법이 먹히는 이유는 각 클래스와 모듈의 성격이 어떤 형태를 띄게 될지 모르기 때문임. 즉 프로그램을 개발하는 과정에서 해당 클래스나 모듈의 속성과 기능을 정의하게 되고 이에 맞게 그 때에 맞는 문맥, 연관성을 고려해서 리팩터링(유지보수)가 일어나기 때문.
<br>&nbsp; 위와 같은 관점에서 유지보수는 배포 이후에만 이루어지는 것이 아니라 프로그램을 개발하면서 지속적으로 수행하는 것. 건축가의 집짓기처럼 구조가 완성된뒤에도 지속적으로 문의 색깔을 바꾸고, 주변환경을 고려해서 가구배치를 새로하고 등등...
<br>&nbsp; 올바른 객체지향설계의 이미지와도 같은 맥락인 것은 일단 모든 구조를 이어서 돌아가게 만든 다음 조금씩 개선해나간다. 프로그램에서도 구조를 잇고 이후에 작성하는 모든 코드들은 유지보수(리팩터링)에 해당하는 것 같다. 설계자의 역할(좋은 설계)는 이 이 유지보수가 쉽게하고 전체 흐름을 이해하는데에 있다.

* 인터페이스가 프로그램이라는 사실, 그리고 인터페이스 구조가 프로그램 구조를 표현해야 한다는 사실도 신중하게 기억해야 하겠지만, 설계가 코드 속에 존재한다는 겸손한 자세도 지속적으로 받아들여야 한다. **제조업이란 메타포에서 재작업은 비용을 뜻하지만 소프트웨어 설계에서 재작업은 가치를 가져온다. 설계는 과정이지 고착된 종착점은 아니다.**

* 다코드에 정직하고, 코드의 상태에 관하여 동료들에게 정직하고, 무엇보다도, 자기 코드에 대해서 자신에게 정직하라는 뜻이다. "처음 왔을 때보다 캠프장을 더 깨끗하게 정리했는가?" 이것은 부수적으로 고려할 사항이 아니다. 애자일이 추구하는 핵심적인 가칭 부합하는 사항이다. **아키텍쳐도, 깨끗한 코드도, 완벽을 주장하지는 않는다. 단지 최선을 다해 정직하라 요구할 뿐이다. 오류는 인간의 본성이고 용서는 신의 본성이다.** 스크럼에서 우리는 모든 것을 드러낸다. 더러운 빨래를 기꺼이 공개한다. 코드는 결코 완벽하지 않으므로 자신의 코드 상태를 정직하게 말한다.

* 고상한 통찰을 끝냈으니 이제 내 책상이나 치우러 가야겠다.

## 들어가면서

* 장인 정신을 익히는 과정은 두 단계로 나뉜다 바로 이론과 실전이다. 첫째 장인에게 필요한 원칙, 패턴, 기법, 경험이라는 지식을 습득해야 한다. 둘째, 열심히 일하고 연습해 지식을 몸과 마음으로 체득해야 한다.

* **깨끗한 코드를 작성하는 방법은 배우기 어렵다.** 단순히 원칙과 패턴을 안다고 깨끗한 코드가 나오지 않는다. 고생을 해야 한다. 스스로 연습하고 실패도 맛봐야 한다. 남들이 시도하다 실패하는 모습도 봐야 한다. 그들이 넘어지고 일어서는 모습도 봐야 한다. 결정을 내리느라 고민하는 모습, 잘못된 결정으로 대가를 치르는 모습도 봐야 한다.

### 코드가 존재하리라
### 나쁜코드
* 나중은 결코 오지 않는다.
### 나쁜 코드로 치르는 대가
* 나쁜 코드는 개발 속도를 크게 떨어 뜨린다. 프로젝트 초반에는 번개처럼 나가다가 1-2년만에 굼벵이처럼 기어가는 팀도 많다. .. 생산성은 점점 떨어져 0이 된다.

* 코드가 정말이지 너무도 엉망이라 몇 시간으로 예쌍한 업무가 몇 주로 늘어진 경험이 있는가? 한줄만 고치면 되리라 예상했다가 모듈을 수백 개 건드린 경험이 있는가? 너무 자주 접하는 모습이다.

* **나쁜코드를 양산하면 기한을 맞추지 못한다. 오히려 엉망진창인 상태로 인해 속도가 곧바로 떨어지고, 결국 기한을 놓친다. 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.**

* 깨끗한 코드를 구현하는 행위는 그림을 그리는 행위와 비슷한다. 깨끗한 코드와 나쁜 코드를 구분할줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다. ... 어떤 사람은 코드 감각을 타고난다. 어떤 사람은 투쟁해서 얻어야 한다. ... 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.

### 깨끗한 코드란?
* 비야네 스트롭스트룹 : 나는 우아하고 효율적인 코드를 좋아한다. 우아하다는 것은 **보기에 즐거운** 코드이다. ... 나쁜 코드는 나쁜 코드를 유혹한다. ... 철저한 오류처리도 언급한다. 세세한 사항까지 꼼꼼하게 신경써라. ... 메모리 누수, 경쟁상태, 일관성 없는 명명법을 지양해라. .. **깨끗한 코드는 한가지에 집중한다.**

* 그래디 부치 : 깨끗한 코드는 단순하고 직접적이다. 잘 쓴 문장처럼 익힌다. 자신이 읽은 책 중 진짜로 좋았떤 책을 떠올려보라. 책을 읽는 동안 단어가 사라지고 이미지가 떠오르지 않았는가? 마찬가지로 깨끗한 코드는 해결할 문제의 긴장을 명확히 드러내야 한다.

* 데이브토마스 : API는 명확하고 최소로 줄인다. 특정 목정을 달성하는 방법은 (여러가지가 아니라) 한가지만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. **아무리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다.**

* 론 제프리스 : 중요한 순으로 나열하자면 간단한 코드는
<br>&nbsp;  1. 모든 테스트를 통과한다.
<br>&nbsp;  2. 중복이 없다.
<br>&nbsp;  3. 시스템 내 모든 설계 아이디어를 표현한다.
<br>&nbsp;  4. 클래스, 메서드, 함수 등을 최대한 줄인다.
<br>&nbsp;  물론 나는 주로 중복에 집중한다. 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. ... 나는 확정하기 전에 이름을 여러 차례 바꾼다. ... 나는 여러 기능을 수행하는 객체나 메서드도 찾는다. 객체가 여러 기능을 수행한다면 여러 객체로 나눈다. **중복과 표현력만 신경써도 깨끗한코드라는 목표에 성큼 다가선다.** ... 자주 쓰는 것은 재빨리 추상 클래스나 추상 메서드로 감싼다. 지금은 간단하게 재빨리 구현했따가 나중에 필효할 때 바꾸면 된다. **게다가 추상화하면 '진짜' 문제에 신경 쓸 여유가 생긴다. 간단한 찾기 기능이 필요한데 온갖 집합 기능을 구현하느라 시간과 노력을 낭비할 필요가 없어진다.**

* 워드 커닝햄 : **코드를 읽으면서 짐작했떤 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.** 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다고 워드는말한다. 읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드다.

### 우리는 저자다
**코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.**

### 보이스카우트 규칙

## 의미있는 이름

이름을 잘 짓는 몇가지 간단한 규칙

### 의도를 분병히 밝혀라
좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.

```java
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays
```

```java
//before
if(cell[STATUS_VALUE] == FLAGGED)

//
if(cell.isFlagged())
```

### 그릇된 정보를 피하라

* 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 accountList라고 명명하지 않는다. 프로그래머에거 List는 특별한 의미이다. 따라서 `accountGroup` 또는 `bunchOfAccounts`라 명명한다.

* 서로 흡사한 이름을 사용하지 않도록 주의한다.

* 유사한 개념은 유사한 표기법을 사용한다. 이것도 정보다. 일관성이 떨어지는 표기법은 그릇된 정보다.

### 의미있게 구분하라

* 동일한 범위 안에서는 다른 두개념에 같은 이름을 사용하지 못한다. 컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 적절하지 못하다. 이름이 달라야 한다면 의미도 달라져야 한다.

* 불용어는 중복이다. 변수이름에 variable이라는 단어는 단연코 금물이다. 표 이름에 table이라는 단어도 마찬가지다 `NameString`이 `Name`보다 뭐가 나은가? `Name`이 부동소수가 될 가능성이 있던가? **코드를 읽다가 Customer라는 클래스와 CustomerObject라는 클래스를 발견했다면 차이를 알겠는가?**

```java
// 잘못된 예제
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```
* 개발에 참여하지 않은 프로그래머는 어느 함수를 호출할지 어떻게 알까?

### 발음하기 쉬운 이름을 사용하라.

### 검색하기 쉬운 이름을 사용하라.

* 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다.

* 짧은 변수들은 검색하기가 굉장히 까다로우므로 이런관점에서 긴 변수명이 낫다.

* **이름 길이는 범위 크기에 비례해야 한다.**

### 인코딩을 피하라

##### 헝가리식 표기법
* 당시에는 컴파일러가 타입을 점검하지 않았으므로 프로그래머에게 타입을 기억할 단서가 필요했다. 접두어에 타입명을 명시. 현재는 IDE에서 타입오류를 점검하므로 그럴 필요가 없다.

```java
// 타입이 바뀌어도 이름은 바뀌지 않는다.
PhoneNumber phoneString
```
##### 멤버 변수 접두어

* 이제는 멤버 변수에 `m_`이라는 접두어 x, IDE에서 멤버변수는 색상으로 구분이 가능. 결국 접두어는 구닥다리 방식일 뿐이다.

##### 인터페이스와 접두어

* `ShapeFactory`와 `ShapeFactoryImpl`이 좋겠다.

### 자신의 기억력을 자랑하지 마라
* 문자 하나만 사용하는 변수 이름은 문제가 있다. 루프에서 반복 횟수를 세는 변수 i, j, k는 괜찮다.
* 똑똑한 프로그래머와 전문가 프로그래머 사이에서 나타나는 차이점 하나만 들자면, 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다. 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다.

### 클래스이름
* 클래스이름과 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account, AddressParser등이 좋은 예다. Manager, Processor, Data, Info 등과 같은 단어는 피하고 동사는 사용하지 안흔다.

### 메서드 이름
* 메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save등이 좋은 예다. 접근자(Accessor), 변경자(Mutor), 조건자(Predicate)는 javabean 표준에 따라 값 앞에 get, set, is를 붙인다.

* **생성자를 중복정의할 때는 정적 팩터리 메서드를 사용한다.** 메서드는 인수를 설명하는 이름을 사용한다.

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0); // 잘된 예
Complex fulcrumPoint = new Complex(23.0); // 못된 예
```

### 기발한 이름을 피하라

### 한 개념에 한 단어를 사용하라.
* 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. 예를들어 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다.

### 말장난을 하지 마라
* 하지만 때로는 프로그래머가 같은 맥락이 아닌데도 '일관성'을 고려해 add라는 단어를 선택한다. 지금까지 add라는 단어를 사용했지만 같은 맥락이 아니라면 insert나 append라는 이름이 적당하다.

### 해법 영역에서 가져온 이름을 사용하라.
* 모든 이름을 문제영역(domain) 가져오는 정책은 현명하지 못하다. `JobQueue`를 모르는 프로그래머가 있을까? 기술개념에는 기술이름이 가장 적합한 선택이다.

### 문제 영역에서 가져온 이름을 사용하라.
* **우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야 한다. 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.**

### 의미 있는 맥락을 추가하라.
* 함수를 끝까지 읽어보고 나서야 number, verb, pluarlaModifier라는 변수 세개가 '통계추측'에 사용된다는 사실이 드러난다. 불행히도 독자가 맥락을 유추해야 한다. **이때는 맥락을 추가하는데 일단 변수를 세 변수를 함수 전반에 걸쳐서 사용한다. 함수를 작은 조각으로 쪼개고자 GuessStaticsMessage** 라는 클래스를 만든 후 세 변수를 클래스에 넣었다. 그러면 세 변수는 맥락이 분명해진다. 즉 세 변수는 확실하게 GuessStatisticsMessage에 속한다. 이렇게 맥락을 개선하면 함수를 쪼개기가 쉬워지므로 알고리즘도 훨씬 더 명확해진다.

```java
// 잘못된예. 맥락이 불분명한 경우 독자가 맥락을 유추한다.
private void printGuessStatistics(char candidate, int count){
  String number;
  String verb;
  String pluraModifier;

  if(count == 0){
    number = "no";
    verb = "are";
    pluraModifier = "s"
  } else if(count==0){
    ...
  } else if(count==1){
    ...
  } else {

  }

  String guessMessage = String.format(
    "There %s %s %s%s", verb, number, candidate, pluarlaModifier
  );
  print(guessMessage
  )
}

// 잘된예 맥락을 추가한다.
public class GuessStaticsMessage {
  private String number;
  private String verb;
  private String pluraModifier;

  public String make(char candidate, int count) {
    createPluralDependentMessageParts(count);
    return String.format(
      "There %s %s %s%s", verb, number, candidate, pluarlaModifier
    );
  }

  private createPluralDependentMessageParts(int count){
    if(count == 0){
      thereAreNoLetters();
    } else if(count==1){
      thereIsOneLetter();
    } else {
      thereAreManyLetters();
    }
  }
  private void thereAreNoLetters(){
    number = "no";
    verb = "are";
    pluraModifier = "s"
  }

  private void thereAreManyLetters(){
    //..
  }

  private void thereIsOneLetter(){
    //..
  }

}
```

### 불필요한 맥락을 없애라.

* Gas Station Deluxe라는 어플리케이션을 짠다고 가정할때 모든 클래스의 이름을 GSD로 시작하겠다는 생각은 전혀 바람직하지 못하다.

* 일반적으로 짧은 이름이 긴 이름보다 좋다. 단 의미가 분명한 경우 불필요한 맥락은 제거한다.

* `accountAddres`와 `customerAddress`는 `Address`클래스 인스턴스로는 좋은 이름이나 클래스 이름으로는 적합하지 못하다. `Address`는 클래스 이름으로 적합하다. 포트 주소, MAC주소, 웹주소를 구분해야 한다면 PostalAddress, MAC, URI라는 이름도 괜찮겠다. 그러면 의미가 좀 더 분명해진다. 바로 이것이 이름을 붙이는 이유가 아니던가.

### 마치면서

* 좋은 이름을 선택하는 능력은 기술, 비즈니스, 관리 문제가 아니라 교육 문제다. **우리들 대다수는 자신이 짠 클래스 이름과 메서드 이름을 모두 암기하지 못한다** 암기는 요즘 나오는 도구들에게 맡기고, 우리는 문장이나 문단처럼 읽히는 코드 아니면 적어도 표나 자료 구조처럼 읽히는 코드를 짜는 데만 집중해야 마땅하다.

## 3장 함수
