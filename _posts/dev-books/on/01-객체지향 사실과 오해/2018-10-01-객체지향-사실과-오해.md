---
layout: post
title: 객체지향 사실과 오해 
author: 조영호
category: dev-book
bookCoverUrl : http://image.kyobobook.co.kr/images/book/large/766/l9788998139766.jpg
slug: rorcpwlgidtktlfrhkdhg
onReading: true
hasSummary: true
---

# 2장 이상한나라의 객체
* 객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 상태(state), 행동(behavior), 식별자(identity)를 지닌 실체로 보는 것이 가장 효과적이다 Booch
* 행동은 객체의 현재 상태에 영향을 받지만, 현재 상태에 영향도 준다.
* 행동의 순서도 중요하다.

### 상태
* 행동의 이력을 기억하는 것은 복잡하므로 상태에 저장한다.

### 상태와 프로퍼티
* 숫자 문자열 양 속도 시간 날짜 참거짓과 같은 단순한 값들은 객체가 아니다. 이런 값은 자체로 독립적인 의미를 가지기보가 다른 객체의 특성을 나타내는데 사용한다.
* 모든 객체의 상태는 단순한 값과 다른 객체의 조합으로 표현할 수 있다. 이 때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티라고한다.
* 프로퍼티는 고정이지만 프로퍼티 값(property value)는 동적이다.
* 객체와 객체 사이의 의미있는 연결을 링크(link)하고 한다. 링크가 있어야 객체간 통신이 가능하다
* 객체의 프로퍼티는 두가지 종류의 조합으로 표현이 가능하다. 하나는 속성(attribute)이고 다른 하는 객체 링크(link).- 객체가 프로퍼티 밸류가 될 수 있다 - 단순한 값은 속성 attribute이다.

### 협력과 행동
* 어떤 객체도 섬이 아니다. 자신에게 주어진 책임을완수하기 위해 적극적으로 다른객체를 이용하고 서비스를 제공한다.
* 행동으로 인해 발생하는 결과
* 객체 자신의 상태 변경
* 행동 내에서 협력하는 다른 객체에 대한 메세지 전송
* 현실과 차이점은 음료가 주체가 된다. 앨리스는 음료를 마셨지만 앨리스가 음료객체의 상태를 직접 변경 할 수 없다. 마셨다는 메시지만 음료객체에게 전달하면, 적절한 정도로 음료의 앙을 줄이는 것은 메시지를 전달받은 음료 스스로의 몫이다.

### 캡슐화
* 전달하는 것은 drunken()이지만 이것이 안에 상태를 변화 시킬지 없을지는 알 수 없다. 상태의 변화는 전적으로 수신자에게 맡긴다
* 자율적인 객체는 스스로 판단하고 스스로 결정하기 때문에 객체의 자율성에 높아질수록 객체의 지능도 높아진다. 협력에 참여하는 객체들의
* 지능이 높아질수록 협력은 유연하고 간결해진다.
### 식별자
* 상태를 기반으로 객체의 동일성을 판단할 수 없는 이유는 시간이 흐름에 따라 객체의 상태가 변하기 때문이다. 비교하는 시점에 따라 객체끼리 상태는 같을수도 다를 수도 있다.
* 오해의 소지를 줄이기 위해 참조객체 값객체로 나눠서 부른다

### 객체
* 일반적으로 객체의 상태를 조회하는 작업을 쿼리(query)라고 하고 객체의 상채를 변경하는 작업을 명령(command)라고 한다.
* 협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다. ... 설계자로서 우리는 협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조해야한다. 객체의 적합성을 결정하는 것은 상태가 아니라 객체의 행동이다.
* 객체지향은 현실세계의 모방이 아니다. 그보다는 은유이다.
* 바로 이러한 이유로 모든 객체지향 지침서에는 형실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드하는 것이다.

# 3장 타입과 추상화
* 일단 컴퓨터를 조작하는 것이 추상화를 구축하고 , 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 컴퓨터 프로그램을 작성하기 위한 중요한 전제 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다. - 키스데블린 2003
초기의 지하철 노선도는 불규칙한 역간의 거리를 사실적으로 묘사하고 있다. 오히려 이 점이 승객들로 하여금 이해하기 어렵게 만들었다. 목적은 하나의 역에서 다른 역으로 이동하는 것 뿐. 따라서 사실적 지형 묘사가 아니라 역과 역 사이의 연결성을 얼마나 직관적으로 표현했냐이다.

* 헤리 벡이 창조한 지하철 노선도의 핵심은 정확성을 버리고 그 목적에 집중한 결과다. 즉 지하철 노선을 추상화한 것이다.
* 진정한 의미의 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다.(root-bernstein 2001). 지하철 사례에서는 정확성을 버리고 연결성을 취했다.
* 추상화는 복잡한 현실을 단순화 한다. 훌륭한 추상화는 목적에 부합한다.
* "현상은 복잡하다. 법칙은 단순하다. 버릴 게 무엇인지 알아내라"
* 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다(Kramer 2007)
* 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
* 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

(내생각) 추상화를 하면 그것에 대해 기대하는 것은 추상화 된 것만 기대하면 volume을 추상화 했으면 그 객체에서는 volume up, volume down 행동만 구현되어 있으면 됨, 다른 추상화는 거기에 해당하는 행위만 구현 되어 있으면 됨. 자바에서는 interface로 강제하지만 js에서는 그냥 프로퍼티에 이것이 있는지 확인만 하고 넘어가면 됨.

* 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
* 개념의 세가직 관점
* 객체의 분류 장치로서 개념은 아래 세가지 관점을 함께 언급한다.
  * 심볼: 개념을 가르키는 간략한 이름이나 명칭
  * 내연: 개념의 완전한 정의
  * 외연: 개념에 속하는 모든 객체의 집합.
개념을 이용해 공통점을 가진 객체들을 분류할 수 있다는 아이디어는 객체지향 패러다임이 복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단이기 때문이다.

(내생각) 여기서 개념은 인터페이스와 비슷하지 않을까?

분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

### 타입은 개념이다.

* 데이터는 실제로 0과 1로 이루어져있지만 타입을 부여함으로써 어떻게 표현되는지 알지 못해도. 연산자를 통해 사용할 수 이다. 그리고 문자열 타입이라면 문자열 연산을, 숫자열 타입이였다면 +, -, *과 같은 연산자를 사용할 수 있을 것이다.
* 즉. 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.
* 데이터 타입은 객체지향의 타입 사이에 깊은 연관성이 있기 때문이다.
* 그렇다면 객체는 데이터인가? 그렇지 않다. 다시 한번 강조하지만 객체에서 중요한 것은 객체의 행동이다.(협력)

### 행동이 우선이다.
* 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다. 결론적으로 객체의 타입을 결정하는 것은 객체의 행동뿐이다.
* 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다.
* 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.
* 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 이 원칙을 흔히 캡슐화라고 한다. 공용 인터페이스 뒤로 데이터를 캡슐화하라는 오래된 격언은 객체를 행동에 따라 분류하기 위해 지켜야하는 기본적인 원칙이다.
* 행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야하는 데이터가 아니라 객체가 위부에 제공해야 하는 행동을 먼저 생각해야 한다.
* 흔히 책임-주도 설계라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 데이터-주도 설계 방법의 단점을 개선하기 위해 고안됐다.

### 일반화/특수화
두 타입간에 일반화/특수화 관계가 성립 하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다. 내부에 보관한 데이터로 구분하는 것이 아니다.

### 슈퍼타입과 서브타입
일반화/특수화 관계는 좀 더 일반적인 타입을 슈퍼타입이라고 하고, 특수한 타입을 서브타입이라고 한다.
따라서 어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다.(리스코프 1988)
​
