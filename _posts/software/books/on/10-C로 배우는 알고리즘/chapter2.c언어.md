

### 2.3.1 c 언어의 특징

> c 언어는 작은 언어이기 때문에 그것을 설명하는 책도 작을 수 밖에 없다. 

c 언어가 규정하고 있는 것이라고는 30여 가지의 예약어(주로 제어구조와 데이터형에 관한것) 그리고 40여 가지의 연산자들, 이들이 조합되는 문법 규칙들 뿐이다.

# 포인터
포인터의 구성요소
* 내용으로 가지는 주소
* 데이터의 형

```c
int *iptr /* 정수형을 가르키는 포인터 => int형의 자료를 가르키는 주소 */

// 위와 혼동 금지
j = *iptr; /* 주소의 내용을 참조한다. iptr은 반드시 포인터여야 한다. */
```

### 포인터 연산자
포인터를 지원하기 위한 연산자
 * `&(address of)` 연산자 : 변수의 주소를 구한다
 * `*(dereference)` 연산자 :  가르키는 주소의 내용을 참조한다
 * `+` `-` : 현재 주소를 참조해 주소를 옮겨준다.
 * `->` : 구조체의 포인터와 작용해서 구조체의 포인터의 멤버들을 지정하게 하는 연산자

i의 주소를 변수 iptr에 담으려면 아래와 같다.

```c
iptr = &i; // i의 주소를 리턴한다.
```

포인터가 가르키는 주소의 내용을 참조하는 `*`연산자는 포인터 정의에도 쓰기 때문에 혼돈이 없어야 한다. `*` 연산자 뒤에는 반드시 포인터가 와야하며 결과로는 **포인터가 가르키는 주소의 내용을 리턴한다.**


```c
j = *iptr;
```


예제
```c
struct coord {
    int x;
    int y;
}

struct coord c, *cptr;
cptr = &c;

// c의 멤버를 참조
c.x = 100;
c.y = 150;

// 포인터로 구조체를 참조할 때는
cptr->x = 100; // -> 연산자의 좌변에는 반드시 구조체의 포인터형이 되어야 한다.
cptr->y = 150;
```

### 2.4.4 포인터의 포인터
C에서는 문자열이라는 데이터형이 없다. 대신 C에서는 char 형의 포인터로 문자열을 나타낸다.

```c
char str1[] = "This is string"
char *str2 = "This also is string"
```

둘다 문자열을 나타내었지만 하나는 배열로, 하나는 포인터로 나타낸 것이다. 둘의 다른점은 str1은 배열의 이름이기 때문에 자체의 주소를 저장하기 위한 공간을 갖지 않는 상수라는 것이다. 반면에 str2는 포인터이기 때문에 주소를 저장하기 위한 공간을 할당 받는다. 그러므로 내용인 주소값은 얼마든지 변경이 가능하다. 이 점만 제외하면 포인터와 배열은 마치 동일한 것처럼 취급해도 된다.

""는 사이에 있는 문자열을 **정적 데이터 영역에 저장하며** = 연산자와 쓰일때는 그 선두 번지를 의미한다. 그래서 str1은 그 정적 데이터 영역의 선두 번지를 나타내는 상수이며, str2는 포인터이므로 정적 데이터 영역의 선두 번지가 포인터 변수에 대입된다. 문자열의 끝은 null로 나타냄도 다 알고 있을 것이다. 결론적으로 c에서는 문자열을 가르킬 때는 char형의 포인터가 사용되어야 한다는 것을 알아두자.

그렇다면 문자열의 배열은 어떻게 될까?

```c
char **strarray = {
    "Cat",
    "Dog",
    "Lion",
    "Rat",
}
```

위의 strarray 앞에는 별이 두개 붙었다. 이것이 바로 포인터의 포인터 정의 방법인데 그 내용으로는 문자열의 나열이다. 

...

포인터의 포인터는 개념적으로 어려운게 없다. 근데 어떤 상황에서 써야하는가에 대한 건데, 이는 90%이상 문자열의 배열을 다룰 때 이다.

### void 포인터

void 포인터란 포인터의 두가지 요소중 데이터형이 아직 정해지지 않은 포인터를 의미한다.

따라서 주의할점이 있는데 역참조(deference *) 연산자를 사용하지 못한다는 것이다. - 형변환 연산자를 사용해서 참조가 가능하다. -

```c
void *vptr;
int i;

i = *vptr; // 역참조가 되지 않는다.
i = (*(int*)vptr + 1); // vptr을 (int*)연산을 이용하여 int 포인터로 변환 
```

두번째로 가르키는 곳의 데이터형이 없음으로 해서 +나 -같은 포인터와 정수의 덧셈 뺄셈을 하지못한다. 위와 마찬가지로 형변환을 하면 가능하다.

```c
i = *(vptr + 1); // wrong vptr의 형이 정해지지 않았다.
i = *((int*)vptr + 1); // vptr을 int의 포인터로 변환
```

void 포인터는 데이터형에 관계없이 동작하는 함수를 제작하는데 유용하게 사용할 수 있다.

### 함수 포인터
