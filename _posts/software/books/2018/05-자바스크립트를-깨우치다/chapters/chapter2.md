# 복합 객체는 자바스크립트 자료형 대부분을 속성으로 포함할 수 있다.

# 복합 객체에 다른 객체 포함하기

```js
// 객체 체인을 만들었다.
var object1 = {
    object1_1 : {

    }
    object1_2 : {

    }
}

// 빈배열안에 빈배열안에 빈 배열이 있다.
var myArray = [[[]]]; 

// 함수 안에 함수 안에 함수가 있다.
var myFunction = function() {
    var myFunction = function() {
        var myFunction = function() {

        }
    }
}

// 위를 모두 섞을 수도 있다.
var foo = [{
    foo : [function(){

    }]
}]
```

# 점 표기법과 각괄호 표기법을 사용한 객체 속성 접근
각괄호 표기법은 필요한 경우를 제외하곤 그리 많이 사용되지 않는다.

...

각괄호 표기법은 속성 이름 문자열을 저장하고 있는 변수를 사용해 속성 키에 접근해야 할 때 매우 편리하다.

```js
var object = {
    foo : 'foo';
    bar : 'bar';
}
var string1 = 'foo';
var string2 = 'bar';

console.log(object[string1], object[string2])
```

```
Note
* object.object.object 이를 가르켜 객체 체이닝이라고 한다.
* 자바스크립트에서 객체는 가변적이다. 대부분의 객체들은 언제든 값을 가져오거나 설정하거나 갱신할 수 있다. 
```

# 객체 속성 삭제하기
`delete` 연산자를 사용하면 객체에서 특정 속성을 완전히 제거할 수 있따.

```
Note
* delete 연산자는 프로토타입 체인에 있는 속성을 제거하지 않는다.
* delete 연산자는 객체에서 속성을 제거할 수 있는 유일한 방법이다. 속성을 undefined 또는 null로 설정하면 속성의 값이 변경될 뿐 속성이 삭제되지 않는다.
```

# 객체 속성의 참조를 찾는법
접근한 속성이 객체에 포함되어 있지 않으면 바로 undefined를 반환하는 것이 아니라 프로토타입 체인을 이용해 속성과 메서드를 찾은 후에 값을 반환한다.

예를들어 `myArray.foo`를 탐색하면 바로 undefined를 반환하는 것이 아니라 Array.prototype과 Object.prototype을 탐색한 후에 반환한다.

...

객체의 속성에 접근하면 객체 인스턴스에 해당 속성이 있는지 확인한다. 객체에 속성이 있으면 속성의 값을 반환하고 이때에는 프로토타입체인을 끌어들이지 않았으므로 상속이 발생하지 않는다. 하지만 객체에 찾는 속성이 없으면 자바스크립트는 해당 객체 생성자 함수의 prototype 객체를 뒤적인다.

**모든 객체 인스턴스에는 인스턴스를 만든 생성자 함수를 가리키는 비밀 링크 (`__proto__` 라 부른다.)를 속성으로 가지고 있다. 이 비밀 링크를 사용하면 생성자 함수를 바로 알 수 있어 인스턴스 생성자 함수의 `prototype` 속성에 접근할 때 유용하다.

자바스크립트 객체를 다룰 때 가장 햇갈리는 부분 중 하나이다. 객체는 다른 객체로부터 속성을 상속받을 수 있다. 속성을 공유하는 것이다. 자바스크립트는 프로토 타입 체인을 사용해 네이티브 객체를 모두 이런 식으로 연결해 놓았다.


# `hasOwnProperty`를 사용해 프로토타입 체인에서 상속받은 속성인지 확인하기

`in` 연산자를 사용하면 객체의 속성을 확인할 때 프로토타입 체인에서 상속받은 속성까지 포함하지만, hasOwnProperty 메소드를 사용하면 객체의 속성이 프로토타입 체인에서 상속받지 않은 해당 객체의 고유한 것인지 확인 할 수 있다.

```js
var myObject = {foo : 'value'};
console.log(myObject.hasOwnProperty('foo')); // true
console.log(myObject.hasOwnProperty('toString')); // false
```

# `in` 연산자를 사용해 객체가 주어진 속성을 포함하는지 확인하기
`in` 연산자는 참조한 객체에 포함된 속성은 물론 프로토타입 체인을 통해 상속받은 속성도 확인한다.

```js
var myObject = {foo : 'value'};
console.log('foo' in myObject); // true
console.log('toString' in myObject); // true
```

# `for in` 루프를 사용해 객체의 속성 탐색하기
* for in 루프에는 단점이 하나 있는데, 특정 객체의 속성뿐만 아니라 다른 객체에서 상속받은 속성까지 탐색한다는 것이다. 따라서 굳이 상속받은 속성까지 보고 싶은 경우가 아니라면 `hasOwnProperty()` 메서드를 사용하면 된다.
* 정의 순서와 사용되는 순서는 다를 수밖에 없다.
* 열거할 수 있는(루프에서 탐색할때 보이는) 속성만 for in 루프에서 볼 수 있다. 예를 들어, 생성자 속성은 루프에서 볼 수 없다. 어떤 속성이 열거할 수 있는지는 `propertyIsEnumerable()` 메서드를 사용해 확인할 수 있다.

```js
var cody = {
    age : 23,
    gender : 'male'
}
for(var key in cody) {
    if(cody.hasOwnProperty(key)) console.log(key); // 프로토타입 체인에서 상속받은 속성은 표시하지 않는다.
}
```

# 호스트 객체 vs 네이티브 객체
일반적으로 자바스크립트가 실행되는 환경(예 : 웹브라우저)에는 호스트객체라는 것이 있다. 호스트 객체는 ECMAScript 명세에서 정의되지 않았으나 코드를 실행할 때는 사용될 수 있는 객체를 뜻한다.

예를들어 웹브라우저 환경에서는 window객체와 window객체가 포함한 모든 객체를 호스트 객체로 볼 수 있다

```js
for(x in window) {
    console.log(x);
}
```

위 코드에서 네이티브 자바스크립트 객체는 보이지 않는다.

**웹 브라우저에서 가장 유명한 호스트 객체는 HTML 문서와 동작하는 인터페이스로서 보통은 DOM으로 많이 알려져 있는 것이다.**
```js
for(x in window.document) {
    console.log(x);
}
```

자바스크립트 명세는 호스트 객체에 관여하지 않고, 호스트 객체 역시 자바스크립트 명세에 관여하지 않는다. 자바스크립트에서 제공하는 것(자바스크립트 1.5, ECMAScript3 vs 모질라의 자바스크립트 1.6, 1.7)과 호스트 환경이 제공하는 것 사이에는 구분선이 있으며 이 두가지를 서로 헷갈려선 안 된다.

...

자바스크립트 코드를 실행하는 호스트 환경에는 두가지 객체가 있다.
* 호스트 객체(웹브라우저의 window.location),
    * 네이티브 기능 포함
* 머리객체(head object)
    * 사용자 정의 객체(웹브라우저에서 실행되는 우리가 작성한 코드)를 저장하는 공간

# underscore.js
자바스크립트 1.5에는 객체를 조작하고 관리하는 기능이 부족하다. underscore.js에는 객체를 다루는 기능이 많이 포함되어 있다.